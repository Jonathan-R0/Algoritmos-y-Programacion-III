Object subclass: #AlgoFix	instanceVariableNames: 'trabajadores menorPrecio mejorPintor'	classVariableNames: ''	package: 'TP1'!!AlgoFix methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:43'!registrarPintorDePincel: nombre conValorHora: precio 	""" 	Recibe un nombre y un precio, y registra un pintor de pincel con los datos ingresados.	Precondiciones: Ambos valores deben ser diferentes de nil.	Postcondiciones: deja el pintor de pincel regustrado en la lista de trabajadores y 						 puede ser guardado en una referencia si entra con el menor precio hasta    						 el momento.	"""	| worker error |		((nombre isNil) or: (precio isNil)) ifTrue:[	error := ErrorNilValueGiven new.	error errorInvalidValue.].   (precio < 0)ifTrue:[ 	error := ErrorNumeroNegativo new.	error errorInvalidNumber.].		worker := PintorDePincel crearConPrecio: precio Nombre: nombre Horas: 2 yLitros: 4.	(precio < menorPrecio)ifTrue:[		menorPrecio := precio.		mejorPintor := worker.	].	trabajadores add: worker.	! !!AlgoFix methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:54'!crearPintura: color conPrecioPorLitro: precio manosPincel: manosPincel manosRodillo: manosRodillo	""" 	Recibe datos, crea una pintura con estos y la devuelve.	Precondiciones: los últimos tres parámetros deben ser diferentes de nil.	Postcondiciones: el objeto que se devuelva es una instancia de Pintura, y todos sus datos 						 están inicializados con los valores ingresados.	"""	| pintura error |	((precio isNumber) and: ((manosPincel isNumber) and: (manosRodillo isNumber))) ifFalse:[	error := ErrorNotANumber new.	error errorNaN. ].	pintura := Pintura new.	pintura guardarNombre: color PrecioPorLitro: precio ManosDePincel: manosPincel yManosDeRodillo: manosRodillo.		^(pintura).! !!AlgoFix methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:34'!presupuestoMasBaratoParaPintarMetrosCuadrados: m2 conPintura: pintura 	"""	Crea un presupuesto con los datos ingresados y los pintores disponibles en AlgoFix hasta el momento.	Esto lo hace delegando a la clase Pintor por medio de la función armarPresupuesto().	Precondiciones: pintura y m2 deben ser diferentes de nil, además de que el objeto debe tener al menos						 un pintor registrado.	Postcondiciones: devuelve una instancia de Presupuesto, creado con los datos ingresados, y el pintor						 asignado será el que cobre menos por hora registrado hasta el momento.	"""		| error |		((m2 isNil) or: (pintura isNil)) ifTrue:[	error := ErrorNilValueGiven new.	error errorInvalidValue.].	(mejorPintor = 'Placeholder') ifTrue: [ 	error := ErrorNoHayPintoresIngresados new.	error errorNoHayPintores.].	^(mejorPintor armarPresupuestoConM2: m2 yPintura: pintura).					! !!AlgoFix methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:44'!registrarPintorDeRodillo: nombre conValorHora: precio 	""" 	Recibe un nombre y un precio, y registra un pintor de rodillo con los datos ingresados.	Precondiciones: Ambos valores deben ser diferentes de nil.	Postcondiciones: deja el pintor de rodillo regustrado en la lista de trabajadores y 						 puede ser guardado en una referencia si entra con el menor precio hasta    						 el momento.	"""	| worker error |		((nombre isNil) or: (precio isNil)) ifTrue:[	error := ErrorNilValueGiven new.	error errorInvalidValue.].   (precio < 0)ifTrue:[	error := ErrorNumeroNegativo new.	error errorInvalidNumber.].		worker := PintorDeRodillo crearConPrecio: precio Nombre: nombre Horas: 1 yLitros: 5.	(precio < menorPrecio)ifTrue:[		menorPrecio := precio.		mejorPintor := worker.	].	trabajadores add: worker.! !!AlgoFix methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 18:04'!manoDeObra: n1 masMateriales: n2 	"""	Recibe dos números y devuelve la suma.	Precondiciones: los dos valores, diferentes de nil, deben ser números no negativos.	Postcondiciones: devuelve la suma de los valores ingresados.	"""		| error |		((n1 isNumber) and: (n2 isNumber)) ifFalse:[	error := ErrorNotANumber new.	error errorNaN.].   ((n1 < 0) or: (n2 < 0))ifTrue:[	error := ErrorNumeroNegativo new.	error errorInvalidNumber.].	^(n1+n2).! !!AlgoFix methodsFor: 'initialization' stamp: 'Jony 5/18/2020 22:17'!initialize 	trabajadores := OrderedCollection new.	menorPrecio :=	Float infinity.	mejorPintor := 'Placeholder'.! !Error subclass: #InvalidClass	instanceVariableNames: 'invalidValue'	classVariableNames: ''	package: 'TP1'!InvalidClass subclass: #ErrorNilValueGiven	instanceVariableNames: ''	classVariableNames: ''	package: 'TP1'!!ErrorNilValueGiven methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:32'!errorInvalidValue	self signal: 'No value or nil was given.'.	! !InvalidClass subclass: #ErrorNoHayPintoresIngresados	instanceVariableNames: ''	classVariableNames: ''	package: 'TP1'!!ErrorNoHayPintoresIngresados methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:34'!errorNoHayPintores	self signal: 'No se ingresaron pintores'.	! !InvalidClass subclass: #ErrorNotANumber	instanceVariableNames: ''	classVariableNames: ''	package: 'TP1'!!ErrorNotANumber methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:42'!errorNaN	self signal: 'Error, no ingresó un número'.	! !InvalidClass subclass: #ErrorNumeroNegativo	instanceVariableNames: ''	classVariableNames: ''	package: 'TP1'!!ErrorNumeroNegativo methodsFor: 'signalling' stamp: 'Jony 5/24/2020 17:43'!errorInvalidNumber	self signal: 'Error, número inválido ingresado'.	! !SubclassResponsibility subclass: #Pintor	instanceVariableNames: 'nombre precioPorHora horasNecesarias litrosNecesarios'	classVariableNames: ''	package: 'TP1'!!Pintor methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:44'!guardarCosto: precio Nombre: nombrePintor Horas: horasRecibidas yLitros: litrosRecibidos	"""	Recibe los datos que deben ser almacenados en una instancia de Pintor recién creada.	Precondiciones: nombrePintor debe ser un ByteString, y el resto de elementos números						no negativos, todos diferentes de nil.	Postcondiciones: guarda en los atributos del objeto los datos adquiridos.	"""	| error |	(((precio isNil) or: (nombrePintor isNil)) or: ((horasRecibidas isNil) or: (horasRecibidas isNil))) ifTrue:[	error := ErrorNilValueGiven new.	error errorInvalidValue.].   ((precio < 0) or: ((horasRecibidas < 0) or: (litrosRecibidos < 0)))ifTrue:[	error := ErrorNumeroNegativo new.	error errorInvalidNumber.].	horasNecesarias := horasRecibidas.	litrosNecesarios := litrosRecibidos.	precioPorHora := precio.	nombre := nombrePintor.	! !!Pintor methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:44'!armarPresupuestoConM2: m2 yPintura: pintura	| factorDescuento manoDeObraFinal presupuestoFinal error |		"""	Calcula la mano de obra con los datos ingresados aplicando un descuento del 50% a la mano de obra si hay más de 40m2 que pintar.	Luego delega a la pintura el cálculo del costo de materiales para finalmente armar y devolver el presupuesto.	Precondiciones: m2 debe ser un número no negativo y pintura una instancia de Pintura,						ambas diferentes de nil.	Postcondiciones: devuelve el presupuesto creado con los valores asignados.	"""		factorDescuento := 1.  "Si tenemos más de 40m2 para pintar, dejamos registrado el descuento"	(m2 > 40) ifTrue: [  factorDescuento  := 1/2. ]. 	   (m2 < 0)ifTrue:[	error := ErrorNumeroNegativo new.	error errorInvalidNumber.].		manoDeObraFinal := (m2 * horasNecesarias * precioPorHora * factorDescuento).	presupuestoFinal := self terminarPresupuesto: manoDeObraFinal conPintura: pintura M2: m2 yLitros: litrosNecesarios.	^(Presupuesto crearACargoDe: nombre conCostoTotal: presupuestoFinal).! !!Pintor methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 16:56'!terminarPresupuesto: manoDeObraFinal conPintura: pintura M2: m2 yLitros: litros		^(self shouldBeImplemented).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pintor class	instanceVariableNames: ''!!Pintor class methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:17'!crearConPrecio: precio Nombre: nombre Horas: horas yLitros: litros	"""	Constructor de un objeto cuya clase instanciada es Pintor.	Precondiciones: precio, horas y litros deben ser números no negativos y el nombre 						 un ByteString, todos diferentes de nil.   Postcondiciones: devuelve la instancia de Pintor ya creada con los datos asignados.	"""	| pintor |	pintor := self new.	pintor guardarCosto: precio Nombre: nombre Horas: horas yLitros: litros.	^(pintor).! !Pintor subclass: #PintorDePincel	instanceVariableNames: ''	classVariableNames: ''	package: 'TP1'!!PintorDePincel methodsFor: 'as yet unclassified' stamp: 'Jony 5/23/2020 18:57'!terminarPresupuesto: manoDeObraFinal conPintura: pintura M2: m2 yLitros: litros	"""	Devuelve el costo total del presupuesto, teniendo en cuenta que se usará el pincel.	Precondiciones: debe recibir números no negativos en los costos, y una instania						 de la clase Pintura, diferente de nil.	Postcondiciones: -	"""		^(pintura terminarPresupuestoPincelCon: manoDeObraFinal M2: m2 yLitros: litros).! !Pintor subclass: #PintorDeRodillo	instanceVariableNames: ''	classVariableNames: ''	package: 'TP1'!!PintorDeRodillo methodsFor: 'as yet unclassified' stamp: 'Jony 5/23/2020 18:56'!terminarPresupuesto: manoDeObraFinal conPintura: pintura M2: m2 yLitros: litros	"""	Devuelve el costo total del presupuesto, teniendo en cuenta que se usará el rodillo.	Precondiciones: debe recibir números no negativos en los costos, y una instania						 de la clase Pintura, diferente de nil.	Postcondiciones: -	"""		^(pintura terminarPresupuestoRodillosCon: manoDeObraFinal M2: m2 yLitros: litros).! !Object subclass: #Pintura	instanceVariableNames: 'nombre precioPorLitro manosDePincel manosDeRodillo'	classVariableNames: ''	package: 'TP1'!!Pintura methodsFor: 'as yet unclassified' stamp: 'Jony 5/23/2020 18:56'!terminarPresupuestoPincelCon: manoDeObraFinal M2: m2 yLitros: litrosNecesarios 	"""	Devuelve el costo total del presupuesto con los datos ingresados, usando el pincel.	Precondiciones: el objeto pintura debe haber sido creado, diferente de nil, y los otros dos						deben ser números positivos.	Postcondiciones: devuelve un número no negativo.	"""	^(((m2 * litrosNecesarios * precioPorLitro) + manoDeObraFinal) * manosDePincel).! !!Pintura methodsFor: 'as yet unclassified' stamp: 'Jony 5/23/2020 18:56'!terminarPresupuestoRodillosCon: manoDeObraFinal M2: m2 yLitros: litrosNecesarios  	"""	Devuelve el costo total del presupuesto con los datos ingresados, usando el rodillo.	Precondiciones: el objeto pintura debe haber sido creado, diferente de nil, y los otros dos						deben ser números positivos.	Postcondiciones: devuelve un número no negativo.	"""	^(((m2 * litrosNecesarios * precioPorLitro) + manoDeObraFinal) * manosDeRodillo).! !!Pintura methodsFor: 'as yet unclassified' stamp: 'Jony 5/24/2020 17:54'!guardarNombre: name PrecioPorLitro: precio ManosDePincel: manosPincel yManosDeRodillo: manosRodillo	"""	Guarda los valores recibidos por parámetro en los atributos del objeto.	Precondiciones: todos los valores deben ser números no negativos.	Postcondiciones: deja los datos ingresados en los atributos del objeto.	"""		| error |	((precio < 0) or: ((manosPincel < 0) or: (manosRodillo < 0)))ifTrue:[	error := ErrorNumeroNegativo new.	error errorInvalidNumber.].		nombre := name.	precioPorLitro := precio.	manosDePincel := manosPincel.	manosDeRodillo := manosRodillo.! !Object subclass: #Presupuesto	instanceVariableNames: 'costoTotal pintor'	classVariableNames: ''	package: 'TP1'!!Presupuesto methodsFor: 'as yet unclassified' stamp: 'Jony 5/19/2020 18:45'!valor	"""	Devuelve el costo total asignado dentro del presupuesto.	Precondiciones: -	Postcondiciones: devuelve un número no negativo.	"""		^(costoTotal).! !!Presupuesto methodsFor: 'as yet unclassified' stamp: 'Jony 5/19/2020 18:45'!guardarCosto: costo yNombre: nombre	"""	Guarda los valores recibidos por parámetro en los atributos del objeto.	Precondiciones: costo y nombre, diferentes de nil, deben ser un número y						 un ByteString respectivamente.	Postcondiciones: deja los datos ingresados en los atributos del objeto.	"""		costoTotal := costo.	pintor := nombre.! !!Presupuesto methodsFor: 'as yet unclassified' stamp: 'Jony 5/19/2020 18:45'!responsable	"""	Devuelve el nombre del responsable asignado dentro del presupuesto.	Precondiciones: -	Postcondiciones: devuelve un ByteString.	"""		^(pintor).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Presupuesto class	instanceVariableNames: ''!!Presupuesto class methodsFor: 'as yet unclassified' stamp: 'Jony 5/19/2020 18:32'!crearACargoDe: nombre conCostoTotal: costo	"""	Constructor de un objeto cuya clase instanciada es Presupuesto.	Precondiciones: costo debe ser un número no negativo y el nombre un Bytestring, 						 todos diferentes de nil.   Postcondiciones: devuelve la instancia de Presupuesto ya creada con los datos asignados.	"""		| presupuesto |	presupuesto := self new.	presupuesto guardarCosto: costo yNombre: nombre.	^(presupuesto)	! !